<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Graph Neural Network Interactive Demo</title>
    <style>
        body { font-family: Arial,sans-serif; margin:2rem; }
        h1, h2 { color: #184878; }
        .output { background:#f5f5f5; border-radius:7px; padding:1rem; margin:1rem 0;}
        .section { margin-bottom:2rem; border-bottom:1px solid #ccc; padding-bottom:1rem; }
        input[type="number"], input[type="text"] { width:5em; }
        input.nodevals { width:7em; }
        textarea { width:23em; height:5em; }
    </style>
</head>
<body>
    <h1>Graph Neural Network (GNN) Interactive Demo</h1>
    <div class="section">
        <h2>Network Configuration</h2>
        <label># Nodes: <input type="number" id="numNodes" value="5" min="2"></label>
        <label>Features per Node: <input type="number" id="featureSize" value="3" min="1"></label>
        <label>Hidden Size: <input type="number" id="hiddenSize" value="16" min="1"></label>
        <label>Output Size: <input type="number" id="outputSize" value="2" min="1"></label>
        <label>Message Passing Layers: <input type="number" id="numLayers" value="2" min="1"></label>
        <button onclick="buildGraphInputs()">Apply Config</button>
    </div>
    <div class="section">
        <h2>Node Features</h2>
        <div id="nodeInputs"></div>
    </div>
    <div class="section">
        <h2>Edges (source,target, each on new line)</h2>
        <textarea id="edgeList">0,1
1,2
2,3
3,4
4,0
1,3</textarea>
    </div>
    <div class="section">
        <h2>Target Output</h2>
        <input type="text" id="targetOutput" value="1,0">
        <span style="color:#888">(comma separated)</span>
    </div>
    <div class="section">
        <h2>Training</h2>
        <label>Iterations: <input type="number" id="trainIters" value="100" min="1"></label>
        <button onclick="runGNNTrain()">Train & Predict</button>
    </div>
    <div class="output" id="output"></div>

<script>
class Edge { constructor(source, target) { this.Source = source; this.Target = target; } }
class Graph {
    constructor(numNodes) {
        this.NumNodes = numNodes;
        this.NodeFeatures = Array(numNodes).fill(null).map(() => []);
        this.Edges = [];
        this.AdjacencyList = Array(numNodes).fill(null).map(() => []);
    }
    buildAdjacencyList() {
        for (let i = 0; i < this.NumNodes; i++) this.AdjacencyList[i] = [];
        for (let edge of this.Edges) this.AdjacencyList[edge.Source].push(edge.Target);
    }
}
class Neuron {
    constructor(numInputs) {
        this.Weights = Array(numInputs).fill(0).map(() => (Math.random()-0.5)*0.1);
        this.Bias = 0.0; this.Output = 0.0; this.Error = 0.0;
    }
}
class Layer {
    constructor(numNeurons, numInputs) {
        this.Neurons = Array(numNeurons).fill(null).map(() => new Neuron(numInputs));
    }
}
function sigmoid(x){return 1.0/(1.0+Math.exp(-x));}
function relu(x){return x>0?x:0.0;}

class GraphNeuralNetwork {
    constructor(featureSize, hiddenSize, outputSize, numMPLayers) {
        this.LearningRate=0.01; this.MaxIterations=100;
        this.FeatureSize=featureSize; this.HiddenSize=hiddenSize;
        this.OutputSize=outputSize; this.NumMessagePassingLayers=numMPLayers;
        this.MessageLayers=[]; this.UpdateLayers=[];
        for(let i=0;i<numMPLayers;i++){
            this.MessageLayers.push(new Layer(hiddenSize,i===0?featureSize*2:hiddenSize*2));
            this.UpdateLayers.push(new Layer(hiddenSize,hiddenSize*2));
        }
        this.ReadoutLayer=new Layer(hiddenSize,hiddenSize);
        this.OutputLayer=new Layer(outputSize,hiddenSize);
        this.NodeEmbeddings=[]; this.NewNodeEmbeddings=[];
    }
    messagePassing(graph){
        let N=graph.NumNodes;
        this.NodeEmbeddings=Array(N).fill(null).map((_,i)=>graph.NodeFeatures[i].slice());
        this.NewNodeEmbeddings=Array(N);
        for(let layer=0;layer<this.NumMessagePassingLayers;layer++){
            for(let node=0;node<N;node++){
                let AggregatedMessage=Array(this.HiddenSize).fill(0.0);
                for(let neighbor of graph.AdjacencyList[node]){
                    let ConcatFeatures=this.NodeEmbeddings[node].concat(this.NodeEmbeddings[neighbor]);
                    let Message=[];
                    for(let i=0;i<this.HiddenSize;i++){
                        let sum=this.MessageLayers[layer].Neurons[i].Bias;
                        for(let j=0;j<ConcatFeatures.length;j++)
                            sum+=ConcatFeatures[j]*this.MessageLayers[layer].Neurons[i].Weights[j];
                        Message[i]=relu(sum);
                    }
                    for(let i=0;i<this.HiddenSize;i++)
                        AggregatedMessage[i]+=Message[i];
                }
                if(graph.AdjacencyList[node].length>0){
                    for(let i=0;i<this.HiddenSize;i++)
                        AggregatedMessage[i]/=graph.AdjacencyList[node].length;
                }
                let UpdateInput=this.NodeEmbeddings[node].concat(AggregatedMessage);
                this.NewNodeEmbeddings[node]=Array(this.HiddenSize).fill(0.0);
                for(let i=0;i<this.HiddenSize;i++){
                    let sum=this.UpdateLayers[layer].Neurons[i].Bias;
                    for(let j=0;j<UpdateInput.length;j++)
                        sum+=UpdateInput[j]*this.UpdateLayers[layer].Neurons[i].Weights[j];
                    this.NewNodeEmbeddings[node][i]=relu(sum);
                }
            }
            for(let node=0;node<N;node++)
                this.NodeEmbeddings[node]=this.NewNodeEmbeddings[node].slice();
        }
    }
    readout(graph){
        let N=graph.NumNodes;
        let GraphEmbedding=Array(this.HiddenSize).fill(0.0);
        for(let i=0;i<N;i++)
            for(let j=0;j<this.HiddenSize;j++)
                GraphEmbedding[j]+=this.NodeEmbeddings[i][j];
        for(let i=0;i<this.HiddenSize;i++)
            GraphEmbedding[i]/=N;
        for(let i=0;i<this.HiddenSize;i++){
            let sum=this.ReadoutLayer.Neurons[i].Bias;
            for(let j=0;j<this.HiddenSize;j++)
                sum+=GraphEmbedding[j]*this.ReadoutLayer.Neurons[i].Weights[j];
            this.ReadoutLayer.Neurons[i].Output=relu(sum);
        }
    }
    predict(graph){
        graph.buildAdjacencyList();
        this.messagePassing(graph);
        this.readout(graph);
        let result=[];
        for(let i=0;i<this.OutputSize;i++){
            let sum=this.OutputLayer.Neurons[i].Bias;
            for(let j=0;j<this.HiddenSize;j++)
                sum+=this.ReadoutLayer.Neurons[j].Output*this.OutputLayer.Neurons[i].Weights[j];
            result[i]=sigmoid(sum);
            this.OutputLayer.Neurons[i].Output=result[i];
        }
        return result;
    }
    backPropagateGraph(graph,target){
        for(let i=0;i<this.OutputSize;i++){
            let o=this.OutputLayer.Neurons[i].Output;
            this.OutputLayer.Neurons[i].Error=o*(1-o)*(target[i]-o);
        }
        for(let i=0;i<this.HiddenSize;i++){
            let sum=0.0;
            for(let j=0;j<this.OutputSize;j++)
                sum+=this.OutputLayer.Neurons[j].Error*this.OutputLayer.Neurons[j].Weights[i];
            this.ReadoutLayer.Neurons[i].Error=this.ReadoutLayer.Neurons[i].Output>0?sum*1.0:0.0;
        }
    }
    updateWeights(){
        for(let i=0;i<this.OutputSize;i++){
            for(let j=0;j<this.HiddenSize;j++)
                this.OutputLayer.Neurons[i].Weights[j]+=this.LearningRate*this.OutputLayer.Neurons[i].Error*this.ReadoutLayer.Neurons[j].Output;
            this.OutputLayer.Neurons[i].Bias+=this.LearningRate*this.OutputLayer.Neurons[i].Error;
        }
        for(let i=0;i<this.HiddenSize;i++)
            this.ReadoutLayer.Neurons[i].Bias+=this.LearningRate*this.ReadoutLayer.Neurons[i].Error;
    }
    train(graph,target){
        this.predict(graph);
        this.backPropagateGraph(graph,target);
        this.updateWeights();
    }
}

// Build node feature input boxes
function buildGraphInputs() {
    let numNodes=parseInt(document.getElementById("numNodes").value)||5;
    let featureSize=parseInt(document.getElementById("featureSize").value)||3;
    let nodeInputsDiv=document.getElementById("nodeInputs");
    nodeInputsDiv.innerHTML='';
    for(let i=0;i<numNodes;i++){
        let label=document.createElement('label');
        label.innerText='Node '+i+': ';
        for(let f=0;f<featureSize;f++){
            let inp=document.createElement('input');
            inp.type='text'; inp.value=(Math.random()).toFixed(2);
            inp.className='nodevals'; inp.id=`nfeat_${i}_${f}`;
            label.appendChild(inp);
            if(f<featureSize-1) label.appendChild(document.createTextNode(', '));
        }
        nodeInputsDiv.appendChild(label);
        nodeInputsDiv.appendChild(document.createElement('br'));
    }
}

buildGraphInputs(); // Init UI on load

function runGNNTrain() {
    let numNodes=parseInt(document.getElementById("numNodes").value)||5;
    let featureSize=parseInt(document.getElementById("featureSize").value)||3;
    let hiddenSize=parseInt(document.getElementById("hiddenSize").value)||16;
    let outputSize=parseInt(document.getElementById("outputSize").value)||2;
    let numLayers=parseInt(document.getElementById("numLayers").value)||2;
    let trainIters=parseInt(document.getElementById("trainIters").value)||100;

    // Collect node features from input boxes
    let nodeFeatures=[];
    for(let i=0;i<numNodes;i++){
        let feats=[];
        for(let f=0;f<featureSize;f++){
            let val=parseFloat(document.getElementById(`nfeat_${i}_${f}`).value)||0.0;
            feats.push(val);
        }
        nodeFeatures.push(feats);
    }
    // Parse edges from textarea
    let edgeLines=document.getElementById("edgeList").value.split('\n');
    let edges=[];
    for(let line of edgeLines){
        let vals=line.trim().split(',');
        if(vals.length!==2) continue;
        let s=parseInt(vals[0]), t=parseInt(vals[1]);
        if(isNaN(s)||isNaN(t)) continue;
        if(s<numNodes && t<numNodes)
            edges.push(new Edge(s,t));
    }
    // Parse target output
    let targetVals=document.getElementById("targetOutput").value.split(',');
    let target=[];
    for(let v of targetVals)
        target.push(parseFloat(v));
    if(target.length!==outputSize) {
        document.getElementById("output").innerHTML='<span style="color:red">Error: Target output has wrong size.</span>';
        return;
    }

    // Build graph
    let graph=new Graph(numNodes);
    graph.NodeFeatures=nodeFeatures; graph.Edges=edges;

    // Build GNN
    let gnn=new GraphNeuralNetwork(featureSize,hiddenSize,outputSize,numLayers);

    // Train
    for(let i=0;i<trainIters;i++)
        gnn.train(graph,target);

    // Predict
    let prediction=gnn.predict(graph);

    document.getElementById("output").innerHTML=
        "<b>Prediction:</b> ["+prediction.map(x=>x.toFixed(4)).join(", ")+"]<br>"+
        "<b>Trained for "+trainIters+" iterations.</b>";
}
</script>
</body>
</html>
