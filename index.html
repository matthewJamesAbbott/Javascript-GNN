<!--
MIT License

Copyright (c) 2025 Matthew Abbott

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions: 

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>GNN</title>
    <style>
        * { box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Arial, sans-serif; 
            margin: 0; padding: 1.5rem;
            background: #fafafa;
            color: #1e293b;
        }
        h1 { color: #0f172a; margin-bottom: 0.5rem; }
        h2 { color: #334155; font-size: 1.1rem; margin: 0 0 0.75rem 0; }
        .container { max-width: 1400px; margin: 0 auto; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; }
        .panel { 
            background: white; 
            border-radius: 12px; 
            padding: 1.25rem; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .section { margin-bottom: 1.25rem; }
        .section:last-child { margin-bottom: 0; }
        
        label { display: inline-block; margin: 0.25rem 0.5rem 0.25rem 0; font-size: 0.9rem; }
        input[type="number"], input[type="text"], select { 
            padding: 0.4rem 0.5rem; 
            border: 1px solid #cbd5e1; 
            border-radius: 6px;
            font-size: 0.9rem;
        }
        input[type="number"] { width: 4.5rem; }
        input[type="text"].nodevals { width: 5rem; }
        input.error { border-color: #ef4444; background: #fef2f2; }
        textarea { 
            width: 100%; height: 6rem; 
            padding: 0.5rem; 
            border: 1px solid #cbd5e1; 
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.85rem;
            resize: vertical;
        }
        textarea.error { border-color: #ef4444; background: #fef2f2; }
        
        input[type="checkbox"] { 
            width: 1rem; height: 1rem; 
            vertical-align: middle; 
            margin-right: 0.25rem;
        }
        
        button { 
            padding: 0.5rem 1rem; 
            background: #5a5a5a; 
            color: white; 
            border: none; 
            border-radius: 0; 
            cursor: pointer;
            font-size: 0.9rem;
            margin: 0.25rem 0.25rem 0.25rem 0;
            transition: background 0.2s;
        }
        button:hover { background: #4a4a4a; }
        button:active { background: #3a3a3a; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        button.secondary { background: #5a5a5a; }
        button.secondary:hover { background: #4a4a4a; }
        button.danger { background: #ef4444; border-radius: 0; }
        button.danger:hover { background: #dc2626; }
        
        .error-msg { 
            color: #dc2626; 
            background: #fef2f2; 
            padding: 0.5rem 0.75rem; 
            border-radius: 6px; 
            margin: 0.5rem 0;
            font-size: 0.85rem;
        }
        .success-msg {
            color: #16a34a;
            background: #f0fdf4;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            margin: 0.5rem 0;
            font-size: 0.85rem;
        }
        
        .metrics-panel {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.75rem;
            margin-bottom: 1rem;
        }
        .metric {
            background: #f1f5f9;
            padding: 0.75rem;
            border-radius: 8px;
            text-align: center;
        }
        .metric-label { font-size: 0.75rem; color: #64748b; text-transform: uppercase; }
        .metric-value { font-size: 1.25rem; font-weight: 600; color: #0f172a; }
        
        #lossChart { 
            width: 100%; 
            height: 200px; 
            background: #f8fafc; 
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }
        
        #graphViz { 
            width: 100%; 
            height: 350px; 
            background: #f8fafc; 
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            position: relative;
        }
        #graphCanvas {
            width: 100%;
            height: 100%;
        }
        
        .output-panel {
            background: #f1f5f9;
            padding: 1rem;
            border-radius: 8px;
            font-family: monospace;
            font-size: 0.85rem;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .slider-container { display: flex; align-items: center; gap: 0.5rem; margin: 0.25rem 0; }
        .slider-container input[type="range"] { flex: 1; max-width: 150px; }
        .slider-value { min-width: 3rem; font-size: 0.85rem; color: #64748b; }
        
        .node-inputs-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); 
            gap: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
            padding-right: 0.5rem;
        }
        .node-input-row { 
            display: flex; 
            align-items: center; 
            gap: 0.25rem;
            background: #f8fafc;
            padding: 0.4rem;
            border-radius: 6px;
        }
        .node-input-label { min-width: 3rem; font-size: 0.8rem; color: #64748b; }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e2e8f0;
            border-radius: 3px;
            overflow: hidden;
            margin: 0.5rem 0;
        }
        .progress-fill {
            height: 100%;
            background: #3b82f6;
            transition: width 0.1s;
        }
        
        .legend { font-size: 0.75rem; color: #64748b; margin-top: 0.5rem; }
        
        @media (max-width: 900px) {
            .grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Graph Neural Network</h1>
        <p style="color:#64748b; margin-bottom:1.5rem;">Full backpropagation through all layers with live visualization</p>
        
        <!-- Network Architecture Visualization -->
        <div class="panel section" style="margin-bottom:1.5rem; display:none;" id="networkVizSection">
            <h2>Network Architecture</h2>
            <div id="networkVisualization"></div>
        </div>
        
        <div class="grid">
            <!-- Left Column: Configuration & Inputs -->
            <div>
                <!-- Network Configuration -->
                <div class="panel section">
                    <h2>Network Configuration</h2>
                    <div style="display:flex; flex-wrap:wrap; gap:0.5rem 1rem;">
                        <label># Nodes: <input type="number" id="numNodes" value="5" min="2" max="100"></label>
                        <label>Features/Node: <input type="number" id="featureSize" value="3" min="1" max="64"></label>
                        <label>Hidden Size: <input type="number" id="hiddenSize" value="16" min="4" max="128"></label>
                        <label>Output Size: <input type="number" id="outputSize" value="2" min="1" max="32"></label>
                        <label>MP Layers: <input type="number" id="numLayers" value="2" min="1" max="8"></label>
                    </div>
                    <div style="margin-top:0.75rem;">
                        <label><input type="checkbox" id="undirected" checked> Undirected Graph</label>
                        <label><input type="checkbox" id="selfLoops"> Include Self-Loops</label>
                        <label><input type="checkbox" id="dedupEdges" checked> Deduplicate Edges</label>
                    </div>
                    <div style="margin-top:0.75rem;">
                        <button onclick="applyConfig()">Apply Config</button>
                        <button class="secondary" onclick="randomizeFeatures()">Randomize Features</button>
                        <button class="danger" onclick="resetModel()">Reset Model</button>
                    </div>
                </div>
                
                <!-- Hyperparameters -->
                <div class="panel section">
                    <h2>Hyperparameters</h2>
                    <div class="slider-container">
                        <label>Learning Rate:</label>
                        <input type="range" id="learningRate" min="-4" max="-1" step="0.1" value="-2" oninput="updateSliderDisplay()">
                        <span class="slider-value" id="lrDisplay">0.01</span>
                    </div>
                    <div class="slider-container">
                        <label>Iterations:</label>
                        <input type="range" id="trainIters" min="10" max="1000" step="10" value="200" oninput="updateSliderDisplay()">
                        <span class="slider-value" id="iterDisplay">200</span>
                    </div>
                    <div style="margin-top:0.5rem;">
                        <label>Activation: 
                            <select id="activation">
                                <option value="relu">ReLU</option>
                                <option value="leaky_relu">Leaky ReLU</option>
                                <option value="tanh">Tanh</option>
                                <option value="sigmoid">Sigmoid</option>
                            </select>
                        </label>
                        <label>Loss: 
                            <select id="lossFunction">
                                <option value="mse">MSE</option>
                                <option value="bce">Binary Cross-Entropy</option>
                            </select>
                        </label>
                    </div>
                </div>
                
                <!-- Node Features -->
                <div class="panel section">
                    <h2>Node Features</h2>
                    <div id="nodeInputs" class="node-inputs-grid"></div>
                    <div id="nodeInputError"></div>
                </div>
                
                <!-- Edges -->
                <div class="panel section">
                    <h2>Edges (source,target per line)</h2>
                    <textarea id="edgeList">0,1
1,2
2,3
3,4
4,0
1,3</textarea>
                    <div id="edgeError"></div>
                    <div class="legend" id="edgeStats"></div>
                </div>
                
                <!-- Target Output -->
                <div class="panel section">
                    <h2>Target Output</h2>
                    <input type="text" id="targetOutput" value="1,0" style="width:100%;">
                    <div id="targetError"></div>
                </div>
            </div>
            
            <!-- Right Column: Visualization & Results -->
            <div>
                <!-- Training Controls -->
                <div class="panel section">
                    <h2>Training</h2>
                    <button id="trainBtn" onclick="runGNNTrain()">Train</button>
                    <button id="predictBtn" onclick="runGNNPredict()" disabled>Predict</button>
                    <button id="stopBtn" class="danger" onclick="stopTraining()" disabled>Stop</button>
                    <button class="secondary" onclick="resetModel()">Reset Model</button>
                    <button class="secondary" onclick="saveModel()">Save</button>
                    <button class="secondary" onclick="loadModel()">Load</button>
                    <div class="progress-bar" id="progressContainer" style="display:none;">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                </div>
                
                <!-- Metrics -->
                <div class="panel section">
                    <h2>Training Metrics</h2>
                    <div class="metrics-panel">
                        <div class="metric">
                            <div class="metric-label">Loss</div>
                            <div class="metric-value" id="metricLoss">-</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Iteration</div>
                            <div class="metric-value" id="metricIter">-</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Delta Loss</div>
                            <div class="metric-value" id="metricDelta">-</div>
                        </div>
                    </div>
                    <canvas id="lossChart"></canvas>
                </div>
                
                <!-- Graph Visualization -->
                <div class="panel section">
                    <h2>Graph Visualization</h2>
                    <div id="graphViz">
                        <canvas id="graphCanvas"></canvas>
                    </div>
                    <div class="legend">Node colors represent embedding magnitude. Click nodes to see features.</div>
                </div>
                
                <!-- Output -->
                <div class="panel section">
                    <h2>Output</h2>
                    <div class="output-panel" id="output">Configure and train the network to see predictions.</div>
                </div>
            </div>
        </div>
    </div>

<script>
// ==================== CONFIGURATION ====================

const CONFIG = {
    MAX_NODES: 100,
    MAX_EDGES: 1000,
    MAX_ITERATIONS: 2000,
    ANIMATION_BATCH: 10
};

let isTraining = false;
let stopRequested = false;
let currentGNN = null;
let lossHistory = [];
let graphState = null;

// ==================== CORE DATA STRUCTURES ====================

class Edge {
    constructor(source, target) {
        this.source = source;
        this.target = target;
    }
    equals(other) {
        return this.source === other.source && this.target === other.target;
    }
    toKey() {
        return `${this.source}-${this.target}`;
    }
}

class Graph {
    constructor(numNodes) {
        this.numNodes = numNodes;
        this.nodeFeatures = Array(numNodes).fill(null).map(() => []);
        this.edges = [];
        this.adjacencyList = Array(numNodes).fill(null).map(() => []);
    }
    
    buildAdjacencyList(undirected = false, selfLoops = false) {
        this.adjacencyList = Array(this.numNodes).fill(null).map(() => []);
        
        for (const edge of this.edges) {
            this.adjacencyList[edge.source].push(edge.target);
            if (undirected && edge.source !== edge.target) {
                this.adjacencyList[edge.target].push(edge.source);
            }
        }
        
        if (selfLoops) {
            for (let i = 0; i < this.numNodes; i++) {
                if (!this.adjacencyList[i].includes(i)) {
                    this.adjacencyList[i].push(i);
                }
            }
        }
    }
    
    static deduplicateEdges(edges) {
        const seen = new Set();
        return edges.filter(e => {
            const key = e.toKey();
            if (seen.has(key)) return false;
            seen.add(key);
            return true;
        });
    }
    
    getNeighborCount(node) {
        return this.adjacencyList[node]?.length || 0;
    }
}

// ==================== ACTIVATION FUNCTIONS ====================

const activations = {
    relu: {
        fn: x => Math.max(0, x),
        derivative: x => x > 0 ? 1 : 0
    },
    leaky_relu: {
        fn: x => x > 0 ? x : 0.01 * x,
        derivative: x => x > 0 ? 1 : 0.01
    },
    tanh: {
        fn: x => Math.tanh(x),
        derivative: x => 1 - Math.tanh(x) ** 2
    },
    sigmoid: {
        fn: x => 1 / (1 + Math.exp(-Math.max(-500, Math.min(500, x)))),
        derivative: x => {
            const s = 1 / (1 + Math.exp(-Math.max(-500, Math.min(500, x))));
            return s * (1 - s);
        }
    }
};

// ==================== LOSS FUNCTIONS ====================

const lossFunctions = {
    mse: {
        fn: (pred, target) => {
            let sum = 0;
            for (let i = 0; i < pred.length; i++) {
                sum += (pred[i] - target[i]) ** 2;
            }
            return sum / pred.length;
        },
        derivative: (pred, target) => {
            return pred.map((p, i) => 2 * (p - target[i]) / pred.length);
        }
    },
    bce: {
        fn: (pred, target) => {
            let sum = 0;
            for (let i = 0; i < pred.length; i++) {
                const p = Math.max(1e-7, Math.min(1 - 1e-7, pred[i]));
                sum -= target[i] * Math.log(p) + (1 - target[i]) * Math.log(1 - p);
            }
            return sum / pred.length;
        },
        derivative: (pred, target) => {
            return pred.map((p, i) => {
                const pClamp = Math.max(1e-7, Math.min(1 - 1e-7, p));
                return (-target[i] / pClamp + (1 - target[i]) / (1 - pClamp)) / pred.length;
            });
        }
    }
};

// ==================== NEURAL NETWORK LAYERS ====================

class DenseLayer {
    constructor(numOutputs, numInputs) {
        this.numInputs = numInputs;
        this.numOutputs = numOutputs;
        
        const scale = Math.sqrt(2.0 / (numInputs + numOutputs));
        this.weights = Array(numOutputs).fill(null).map(() =>
            Array(numInputs).fill(0).map(() => (Math.random() - 0.5) * 2 * scale)
        );
        this.biases = Array(numOutputs).fill(0);
        
        this.lastInput = null;
        this.lastPreActivation = null;
        this.lastOutput = null;
        this.weightGrads = null;
        this.biasGrads = null;
    }
    
    forward(input, activation) {
        this.lastInput = input.slice();
        this.lastPreActivation = [];
        this.lastOutput = [];
        
        for (let i = 0; i < this.numOutputs; i++) {
            let sum = this.biases[i];
            for (let j = 0; j < this.numInputs; j++) {
                sum += this.weights[i][j] * input[j];
            }
            this.lastPreActivation[i] = sum;
            this.lastOutput[i] = activation.fn(sum);
        }
        
        return this.lastOutput;
    }
    
    backward(upstreamGrad, activation, learningRate) {
        const preActGrad = [];
        for (let i = 0; i < this.numOutputs; i++) {
            preActGrad[i] = upstreamGrad[i] * activation.derivative(this.lastPreActivation[i]);
        }
        
        this.weightGrads = Array(this.numOutputs).fill(null).map(() => Array(this.numInputs).fill(0));
        this.biasGrads = Array(this.numOutputs).fill(0);
        
        for (let i = 0; i < this.numOutputs; i++) {
            this.biasGrads[i] = preActGrad[i];
            for (let j = 0; j < this.numInputs; j++) {
                this.weightGrads[i][j] = preActGrad[i] * this.lastInput[j];
            }
        }
        
        const inputGrad = Array(this.numInputs).fill(0);
        for (let j = 0; j < this.numInputs; j++) {
            for (let i = 0; i < this.numOutputs; i++) {
                inputGrad[j] += this.weights[i][j] * preActGrad[i];
            }
        }
        
        for (let i = 0; i < this.numOutputs; i++) {
            this.biases[i] -= learningRate * this.biasGrads[i];
            for (let j = 0; j < this.numInputs; j++) {
                this.weights[i][j] -= learningRate * this.weightGrads[i][j];
            }
        }
        
        return inputGrad;
    }
    
    getWeights() {
        return { weights: this.weights.map(w => w.slice()), biases: this.biases.slice() };
    }
    
    setWeights(data) {
        this.weights = data.weights.map(w => w.slice());
        this.biases = data.biases.slice();
    }
}

// ==================== GRAPH NEURAL NETWORK ====================

class GraphNeuralNetwork {
    constructor(featureSize, hiddenSize, outputSize, numMPLayers) {
        this.featureSize = featureSize;
        this.hiddenSize = hiddenSize;
        this.outputSize = outputSize;
        this.numMPLayers = numMPLayers;
        this.learningRate = 0.01;
        this.activationType = 'relu';
        this.lossFunctionType = 'mse';
        
        this.messageLayers = [];
        this.updateLayers = [];
        
        for (let i = 0; i < numMPLayers; i++) {
            const inputSize = i === 0 ? featureSize * 2 : hiddenSize * 2;
            this.messageLayers.push(new DenseLayer(hiddenSize, inputSize));
            this.updateLayers.push(new DenseLayer(hiddenSize, hiddenSize * 2));
        }
        
        this.readoutLayer = new DenseLayer(hiddenSize, hiddenSize);
        this.outputLayer = new DenseLayer(outputSize, hiddenSize);
        
        this.nodeEmbeddings = [];
        this.embeddingHistory = [];
        this.messageHistory = [];
        this.aggregatedMessages = [];
        this.graphEmbedding = null;
        this.readoutOutput = null;
    }
    
    get activation() {
        return activations[this.activationType];
    }
    
    get lossFunction() {
        return lossFunctions[this.lossFunctionType];
    }
    
    forward(graph) {
        const N = graph.numNodes;
        const activation = this.activation;
        
        this.embeddingHistory = [];
        this.messageHistory = [];
        this.aggregatedMessages = [];
        
        let currentEmbeddings = graph.nodeFeatures.map(f => f.slice());
        this.embeddingHistory.push(currentEmbeddings.map(e => e.slice()));
        
        for (let layer = 0; layer < this.numMPLayers; layer++) {
            const newEmbeddings = [];
            const layerMessages = [];
            const layerAggregated = [];
            
            for (let node = 0; node < N; node++) {
                const neighbors = graph.adjacencyList[node];
                const nodeMessages = [];
                let aggregatedMessage = Array(this.hiddenSize).fill(0);
                
                if (neighbors.length > 0) {
                    for (const neighbor of neighbors) {
                        const concat = currentEmbeddings[node].concat(currentEmbeddings[neighbor]);
                        const message = this.messageLayers[layer].forward(concat, activation);
                        nodeMessages.push({ neighbor, message: message.slice(), concat: concat.slice() });
                        
                        for (let i = 0; i < this.hiddenSize; i++) {
                            aggregatedMessage[i] += message[i];
                        }
                    }
                    
                    for (let i = 0; i < this.hiddenSize; i++) {
                        aggregatedMessage[i] /= neighbors.length;
                    }
                }
                
                layerMessages.push(nodeMessages);
                layerAggregated.push(aggregatedMessage);
                
                let updateInput;
                if (layer === 0) {
                    const paddedFeatures = Array(this.hiddenSize).fill(0);
                    for (let i = 0; i < Math.min(currentEmbeddings[node].length, this.hiddenSize); i++) {
                        paddedFeatures[i] = currentEmbeddings[node][i];
                    }
                    updateInput = paddedFeatures.concat(aggregatedMessage);
                } else {
                    updateInput = currentEmbeddings[node].concat(aggregatedMessage);
                }
                
                const newEmb = this.updateLayers[layer].forward(updateInput, activation);
                newEmbeddings.push(newEmb);
            }
            
            this.messageHistory.push(layerMessages);
            this.aggregatedMessages.push(layerAggregated);
            currentEmbeddings = newEmbeddings;
            this.embeddingHistory.push(currentEmbeddings.map(e => e.slice()));
        }
        
        this.nodeEmbeddings = currentEmbeddings;
        
        this.graphEmbedding = Array(this.hiddenSize).fill(0);
        for (let i = 0; i < N; i++) {
            for (let j = 0; j < this.hiddenSize; j++) {
                this.graphEmbedding[j] += this.nodeEmbeddings[i][j];
            }
        }
        for (let j = 0; j < this.hiddenSize; j++) {
            this.graphEmbedding[j] /= N;
        }
        
        this.readoutOutput = this.readoutLayer.forward(this.graphEmbedding, activation);
        const output = this.outputLayer.forward(this.readoutOutput, activations.sigmoid);
        
        return output;
    }
    
    backward(graph, target) {
        const N = graph.numNodes;
        const activation = this.activation;
        const lr = this.learningRate;
        
        const prediction = this.outputLayer.lastOutput;
        const lossGrad = this.lossFunction.derivative(prediction, target);
        
        const readoutGrad = this.outputLayer.backward(lossGrad, activations.sigmoid, lr);
        const graphEmbGrad = this.readoutLayer.backward(readoutGrad, activation, lr);
        
        const nodeGrads = Array(N).fill(null).map(() => 
            graphEmbGrad.map(g => g / N)
        );
        
        for (let layer = this.numMPLayers - 1; layer >= 0; layer--) {
            const prevEmbeddings = this.embeddingHistory[layer];
            const newNodeGrads = Array(N).fill(null).map(() => 
                Array(layer === 0 ? this.featureSize : this.hiddenSize).fill(0)
            );
            
            for (let node = 0; node < N; node++) {
                let updateInput;
                if (layer === 0) {
                    const paddedFeatures = Array(this.hiddenSize).fill(0);
                    for (let i = 0; i < Math.min(prevEmbeddings[node].length, this.hiddenSize); i++) {
                        paddedFeatures[i] = prevEmbeddings[node][i];
                    }
                    updateInput = paddedFeatures.concat(this.aggregatedMessages[layer][node]);
                } else {
                    updateInput = prevEmbeddings[node].concat(this.aggregatedMessages[layer][node]);
                }
                
                this.updateLayers[layer].lastInput = updateInput;
                const updateInputGrad = this.updateLayers[layer].backward(nodeGrads[node], activation, lr);
                
                for (let i = 0; i < Math.min(this.hiddenSize, newNodeGrads[node].length); i++) {
                    if (layer === 0 && i < this.featureSize) {
                        newNodeGrads[node][i] += updateInputGrad[i];
                    } else if (layer > 0) {
                        newNodeGrads[node][i] += updateInputGrad[i];
                    }
                }
                
                const numNeighbors = graph.adjacencyList[node].length;
                if (numNeighbors > 0) {
                    const msgGrad = Array(this.hiddenSize).fill(0);
                    for (let i = 0; i < this.hiddenSize; i++) {
                        msgGrad[i] = updateInputGrad[this.hiddenSize + i] / numNeighbors;
                    }
                    
                    for (const msgInfo of this.messageHistory[layer][node]) {
                        this.messageLayers[layer].lastInput = msgInfo.concat;
                        const concatGrad = this.messageLayers[layer].backward(msgGrad, activation, lr);
                        
                        const halfLen = concatGrad.length / 2;
                        for (let i = 0; i < Math.min(halfLen, newNodeGrads[node].length); i++) {
                            newNodeGrads[node][i] += concatGrad[i];
                        }
                        for (let i = 0; i < Math.min(halfLen, newNodeGrads[msgInfo.neighbor].length); i++) {
                            newNodeGrads[msgInfo.neighbor][i] += concatGrad[halfLen + i];
                        }
                    }
                }
            }
            
            if (layer > 0) {
                for (let node = 0; node < N; node++) {
                    nodeGrads[node] = newNodeGrads[node];
                }
            }
        }
    }
    
    train(graph, target) {
        const prediction = this.forward(graph);
        const loss = this.lossFunction.fn(prediction, target);
        this.backward(graph, target);
        return { prediction, loss };
    }
    
    predict(graph) {
        return this.forward(graph);
    }
    
    getWeights() {
        return {
            messageLayers: this.messageLayers.map(l => l.getWeights()),
            updateLayers: this.updateLayers.map(l => l.getWeights()),
            readoutLayer: this.readoutLayer.getWeights(),
            outputLayer: this.outputLayer.getWeights(),
            config: {
                featureSize: this.featureSize,
                hiddenSize: this.hiddenSize,
                outputSize: this.outputSize,
                numMPLayers: this.numMPLayers
            }
        };
    }
    
    setWeights(data) {
        data.messageLayers.forEach((w, i) => this.messageLayers[i].setWeights(w));
        data.updateLayers.forEach((w, i) => this.updateLayers[i].setWeights(w));
        this.readoutLayer.setWeights(data.readoutLayer);
        this.outputLayer.setWeights(data.outputLayer);
    }
}

// ==================== INPUT VALIDATION ====================

function validateInputs() {
    const errors = [];
    clearErrors();
    
    const numNodes = parseInt(document.getElementById('numNodes').value);
    const featureSize = parseInt(document.getElementById('featureSize').value);
    const outputSize = parseInt(document.getElementById('outputSize').value);
    
    if (isNaN(numNodes) || numNodes < 2 || numNodes > CONFIG.MAX_NODES) {
        errors.push({ field: 'numNodes', msg: `Nodes must be 2-${CONFIG.MAX_NODES}` });
    }
    
    const nodeFeatures = [];
    for (let i = 0; i < numNodes; i++) {
        const feats = [];
        let hasError = false;
        for (let f = 0; f < featureSize; f++) {
            const el = document.getElementById(`nfeat_${i}_${f}`);
            if (!el) continue;
            const val = parseFloat(el.value);
            if (isNaN(val)) {
                el.classList.add('error');
                hasError = true;
            } else {
                feats.push(val);
            }
        }
        if (hasError) {
            errors.push({ field: 'nodeInputs', msg: `Node ${i} has invalid features` });
        }
        nodeFeatures.push(feats);
    }
    
    const edgeText = document.getElementById('edgeList').value;
    const edges = parseEdges(edgeText, numNodes);
    if (edges.errors.length > 0) {
        document.getElementById('edgeList').classList.add('error');
        errors.push({ field: 'edgeList', msg: edges.errors.join('; ') });
    }
    
    const targetText = document.getElementById('targetOutput').value;
    const targetVals = targetText.split(',').map(v => parseFloat(v.trim()));
    if (targetVals.some(isNaN)) {
        document.getElementById('targetOutput').classList.add('error');
        errors.push({ field: 'targetOutput', msg: 'Target contains non-numeric values' });
    } else if (targetVals.length !== outputSize) {
        document.getElementById('targetOutput').classList.add('error');
        errors.push({ field: 'targetOutput', msg: `Target size (${targetVals.length}) doesn't match output size (${outputSize})` });
    }
    
    return { valid: errors.length === 0, errors, nodeFeatures, edges: edges.edges, target: targetVals };
}

function parseEdges(text, numNodes) {
    const lines = text.trim().split('\n');
    const edges = [];
    const errors = [];
    const deduplicate = document.getElementById('dedupEdges').checked;
    const seen = new Set();
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        
        const parts = line.split(',');
        if (parts.length !== 2) {
            errors.push(`Line ${i + 1}: expected "source,target"`);
            continue;
        }
        
        const s = parseInt(parts[0].trim());
        const t = parseInt(parts[1].trim());
        
        if (isNaN(s) || isNaN(t)) {
            errors.push(`Line ${i + 1}: non-numeric values`);
            continue;
        }
        
        if (s < 0 || s >= numNodes || t < 0 || t >= numNodes) {
            errors.push(`Line ${i + 1}: node index out of range`);
            continue;
        }
        
        const key = `${s}-${t}`;
        if (deduplicate && seen.has(key)) continue;
        seen.add(key);
        
        edges.push(new Edge(s, t));
    }
    
    if (edges.length > CONFIG.MAX_EDGES) {
        errors.push(`Too many edges (max ${CONFIG.MAX_EDGES})`);
    }
    
    return { edges, errors };
}

function clearErrors() {
    document.querySelectorAll('.error').forEach(el => el.classList.remove('error'));
    document.getElementById('nodeInputError').innerHTML = '';
    document.getElementById('edgeError').innerHTML = '';
    document.getElementById('targetError').innerHTML = '';
}

function showError(field, msg) {
    const errorDiv = document.getElementById(field + 'Error') || document.getElementById('output');
    if (errorDiv) {
        errorDiv.innerHTML = `<div class="error-msg">${escapeHtml(msg)}</div>`;
    }
}

function escapeHtml(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
}

// ==================== UI FUNCTIONS ====================

function buildGraphInputs() {
    const numNodes = Math.min(parseInt(document.getElementById('numNodes').value) || 5, CONFIG.MAX_NODES);
    const featureSize = Math.min(parseInt(document.getElementById('featureSize').value) || 3, 64);
    const container = document.getElementById('nodeInputs');
    container.innerHTML = '';
    
    for (let i = 0; i < numNodes; i++) {
        const row = document.createElement('div');
        row.className = 'node-input-row';
        
        const label = document.createElement('span');
        label.className = 'node-input-label';
        label.textContent = `N${i}:`;
        row.appendChild(label);
        
        for (let f = 0; f < featureSize; f++) {
            const inp = document.createElement('input');
            inp.type = 'text';
            inp.className = 'nodevals';
            inp.id = `nfeat_${i}_${f}`;
            inp.value = (Math.random()).toFixed(2);
            row.appendChild(inp);
        }
        
        container.appendChild(row);
    }
    
    updateEdgeStats();
}

function randomizeFeatures() {
    const numNodes = parseInt(document.getElementById('numNodes').value) || 5;
    const featureSize = parseInt(document.getElementById('featureSize').value) || 3;
    
    for (let i = 0; i < numNodes; i++) {
        for (let f = 0; f < featureSize; f++) {
            const el = document.getElementById(`nfeat_${i}_${f}`);
            if (el) el.value = (Math.random()).toFixed(2);
        }
    }
}

function applyConfig() {
    buildGraphInputs();
    currentGNN = null;
    lossHistory = [];
    updateLossChart();
    updateMetrics(null, null, null);
    visualizeGNNArchitecture(null, 'networkVisualization');
    document.getElementById('output').innerHTML = 'Configuration applied. Ready to train.';
}

function updateSliderDisplay() {
    const lr = Math.pow(10, parseFloat(document.getElementById('learningRate').value));
    document.getElementById('lrDisplay').textContent = lr.toFixed(4);
    
    const iters = parseInt(document.getElementById('trainIters').value);
    document.getElementById('iterDisplay').textContent = iters;
}

function updateEdgeStats() {
    const numNodes = parseInt(document.getElementById('numNodes').value) || 5;
    const { edges, errors } = parseEdges(document.getElementById('edgeList').value, numNodes);
    const undirected = document.getElementById('undirected').checked;
    const effectiveEdges = undirected ? edges.length * 2 : edges.length;
    
    document.getElementById('edgeStats').textContent = 
        `${edges.length} edges defined${undirected ? ` (${effectiveEdges} with reverse)` : ''}${errors.length ? `, ${errors.length} warnings` : ''}`;
}

document.getElementById('edgeList').addEventListener('input', updateEdgeStats);
document.getElementById('undirected').addEventListener('change', updateEdgeStats);

// ==================== TRAINING ====================

async function runGNNTrain() {
     if (isTraining) return;
     
     const validation = validateInputs();
     if (!validation.valid) {
         validation.errors.forEach(e => showError(e.field, e.msg));
         return;
     }
     
     isTraining = true;
     stopRequested = false;
     
     document.getElementById('trainBtn').disabled = true;
     document.getElementById('stopBtn').disabled = false;
     document.getElementById('progressContainer').style.display = 'block';
     
     const numNodes = parseInt(document.getElementById('numNodes').value);
     const featureSize = parseInt(document.getElementById('featureSize').value);
     const hiddenSize = parseInt(document.getElementById('hiddenSize').value);
     const outputSize = parseInt(document.getElementById('outputSize').value);
     const numLayers = parseInt(document.getElementById('numLayers').value);
     const undirected = document.getElementById('undirected').checked;
     const selfLoops = document.getElementById('selfLoops').checked;
     
     const learningRate = Math.pow(10, parseFloat(document.getElementById('learningRate').value));
     const trainIters = Math.min(parseInt(document.getElementById('trainIters').value), CONFIG.MAX_ITERATIONS);
     const activationType = document.getElementById('activation').value;
     const lossFunctionType = document.getElementById('lossFunction').value;
     
     const graph = new Graph(numNodes);
     graph.nodeFeatures = validation.nodeFeatures;
     graph.edges = validation.edges;
     graph.buildAdjacencyList(undirected, selfLoops);
     
     const configChanged = !currentGNN || 
         currentGNN.featureSize !== featureSize ||
         currentGNN.hiddenSize !== hiddenSize ||
         currentGNN.outputSize !== outputSize ||
         currentGNN.numMPLayers !== numLayers;
     
     if (configChanged) {
         currentGNN = new GraphNeuralNetwork(featureSize, hiddenSize, outputSize, numLayers);
         lossHistory = [];
     }
     
     currentGNN.learningRate = learningRate;
     currentGNN.activationType = activationType;
     currentGNN.lossFunctionType = lossFunctionType;
     
     // Store graph and target for prediction
     window.lastGraph = graph;
     window.lastTarget = validation.target;
     
     let lastLoss = null;
     
     for (let i = 0; i < trainIters && !stopRequested; i++) {
         const result = currentGNN.train(graph, validation.target);
         lossHistory.push(result.loss);
         
         if (i % CONFIG.ANIMATION_BATCH === 0 || i === trainIters - 1) {
             const delta = lastLoss !== null ? result.loss - lastLoss : null;
             updateMetrics(result.loss, i + 1, delta);
             updateProgress((i + 1) / trainIters * 100);
             updateLossChart();
             updateGraphViz(graph, currentGNN.nodeEmbeddings);
             lastLoss = result.loss;
             
             await new Promise(r => setTimeout(r, 0));
         }
     }
     
     document.getElementById('output').innerHTML = `<div class="success-msg">Training complete. Click Predict to see results.</div>`;
     
     isTraining = false;
     document.getElementById('trainBtn').disabled = false;
     document.getElementById('predictBtn').disabled = false;
     document.getElementById('stopBtn').disabled = true;
 }
 
 function runGNNPredict() {
     if (!currentGNN) {
         alert('Load or train a model first.');
         return;
     }
     
     // Use stored graph/target from training, or build from UI
     let graph = window.lastGraph;
     let target = window.lastTarget;
     
     if (!graph || !target) {
         // Build from UI configuration
         const numNodes = parseInt(document.getElementById('numNodes').value);
         const featureSize = parseInt(document.getElementById('featureSize').value);
         const nodeFeatures = [];
         
         for (let i = 0; i < numNodes; i++) {
             const features = [];
             for (let f = 0; f < featureSize; f++) {
                 const val = parseFloat(document.getElementById(`nfeat_${i}_${f}`)?.value || 0);
                 features.push(isNaN(val) ? 0 : val);
             }
             nodeFeatures.push(features);
         }
         
         const { edges } = parseEdges(document.getElementById('edgeList').value, numNodes);
         const undirected = document.getElementById('undirected').checked;
         const selfLoops = document.getElementById('selfLoops').checked;
         
         graph = new Graph(numNodes);
         graph.nodeFeatures = nodeFeatures;
         graph.edges = edges;
         graph.buildAdjacencyList(undirected, selfLoops);
         
         // Parse target output
         const targetStr = document.getElementById('targetOutput').value.trim();
         target = targetStr.split(',').map(v => parseFloat(v.trim())).filter(v => !isNaN(v));
         
         if (target.length === 0) {
             alert('Please enter target output values (comma-separated).');
             return;
         }
     }
     
     const finalPrediction = currentGNN.predict(graph);
     const finalLoss = currentGNN.lossFunction.fn(finalPrediction, target);
     
     document.getElementById('output').innerHTML = `
         <b>Prediction:</b> [${finalPrediction.map(x => x.toFixed(4)).join(', ')}]<br>
         <b>Target:</b> [${target.join(', ')}]<br>
         <b>Final Loss:</b> ${finalLoss.toFixed(6)}<br>
         ${lossHistory.length > 0 ? `<b>Trained for ${lossHistory.length} iterations</b>` : '<i>Model not trained (using loaded weights)</i>'}
     `;
 }

function stopTraining() {
    stopRequested = true;
}

function resetModel() {
    currentGNN = null;
    lossHistory = [];
    graphState = null;
    updateLossChart();
    updateMetrics(null, null, null);
    document.getElementById('output').innerHTML = 'Model reset. Ready to train.';
    clearGraphViz();
}

// ==================== METRICS & VISUALIZATION ====================

function updateMetrics(loss, iter, delta) {
    document.getElementById('metricLoss').textContent = loss !== null ? loss.toFixed(6) : '-';
    document.getElementById('metricIter').textContent = iter !== null ? iter : '-';
    document.getElementById('metricDelta').textContent = delta !== null ? 
        (delta >= 0 ? '+' : '') + delta.toFixed(6) : '-';
    document.getElementById('metricDelta').style.color = delta !== null ? 
        (delta < 0 ? '#16a34a' : delta > 0 ? '#dc2626' : '#64748b') : '#64748b';
}

function updateProgress(percent) {
    document.getElementById('progressFill').style.width = percent + '%';
}

function updateLossChart() {
    const canvas = document.getElementById('lossChart');
    const ctx = canvas.getContext('2d');
    const rect = canvas.getBoundingClientRect();
    
    canvas.width = rect.width * window.devicePixelRatio;
    canvas.height = rect.height * window.devicePixelRatio;
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    
    const width = rect.width;
    const height = rect.height;
    const margin = { top: 20, right: 20, bottom: 30, left: 50 };
    const innerWidth = width - margin.left - margin.right;
    const innerHeight = height - margin.top - margin.bottom;
    
    ctx.clearRect(0, 0, width, height);
    
    if (lossHistory.length < 2) {
        ctx.fillStyle = '#64748b';
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Loss chart will appear during training', width / 2, height / 2);
        return;
    }
    
    const maxLoss = Math.max(...lossHistory) * 1.1;
    const minLoss = 0;
    
    ctx.strokeStyle = '#e2e8f0';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let i = 0; i <= 5; i++) {
        const y = margin.top + (innerHeight * i / 5);
        ctx.moveTo(margin.left, y);
        ctx.lineTo(margin.left + innerWidth, y);
    }
    ctx.stroke();
    
    ctx.strokeStyle = '#3b82f6';
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    for (let i = 0; i < lossHistory.length; i++) {
        const x = margin.left + (i / (lossHistory.length - 1)) * innerWidth;
        const y = margin.top + innerHeight - ((lossHistory[i] - minLoss) / (maxLoss - minLoss)) * innerHeight;
        
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }
    ctx.stroke();
    
    ctx.fillStyle = '#64748b';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Iteration', margin.left + innerWidth / 2, height - 5);
    
    ctx.save();
    ctx.translate(12, margin.top + innerHeight / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Loss', 0, 0);
    ctx.restore();
    
    ctx.textAlign = 'right';
    ctx.fillText(maxLoss.toFixed(3), margin.left - 5, margin.top + 4);
    ctx.fillText('0', margin.left - 5, margin.top + innerHeight + 4);
    
    ctx.textAlign = 'left';
    ctx.fillText('0', margin.left, height - 15);
    ctx.textAlign = 'right';
    ctx.fillText(lossHistory.length.toString(), margin.left + innerWidth, height - 15);
}

function updateGraphViz(graph, embeddings) {
    const container = document.getElementById('graphViz');
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');
    
    const rect = container.getBoundingClientRect();
    canvas.width = rect.width * window.devicePixelRatio;
    canvas.height = rect.height * window.devicePixelRatio;
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    
    const width = rect.width;
    const height = rect.height;
    
    ctx.clearRect(0, 0, width, height);
    
    if (!graphState || graphState.numNodes !== graph.numNodes) {
        graphState = {
            numNodes: graph.numNodes,
            positions: []
        };
        for (let i = 0; i < graph.numNodes; i++) {
            const angle = (2 * Math.PI * i) / graph.numNodes;
            const radius = Math.min(width, height) * 0.35;
            graphState.positions.push({
                x: width / 2 + radius * Math.cos(angle - Math.PI / 2),
                y: height / 2 + radius * Math.sin(angle - Math.PI / 2)
            });
        }
    }
    
    const undirected = document.getElementById('undirected').checked;
    const drawnEdges = new Set();
    
    ctx.strokeStyle = '#94a3b8';
    ctx.lineWidth = 2;
    
    for (const edge of graph.edges) {
        const key = undirected ? 
            `${Math.min(edge.source, edge.target)}-${Math.max(edge.source, edge.target)}` :
            `${edge.source}-${edge.target}`;
        
        if (drawnEdges.has(key)) continue;
        drawnEdges.add(key);
        
        const p1 = graphState.positions[edge.source];
        const p2 = graphState.positions[edge.target];
        
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
        
        if (!undirected) {
            const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
            const arrowLen = 10;
            const arrowX = p2.x - 20 * Math.cos(angle);
            const arrowY = p2.y - 20 * Math.sin(angle);
            
            ctx.beginPath();
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(arrowX - arrowLen * Math.cos(angle - 0.4), arrowY - arrowLen * Math.sin(angle - 0.4));
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(arrowX - arrowLen * Math.cos(angle + 0.4), arrowY - arrowLen * Math.sin(angle + 0.4));
            ctx.stroke();
        }
    }
    
    const magnitudes = [];
    for (let i = 0; i < graph.numNodes; i++) {
        const emb = embeddings?.[i] || [];
        const mag = Math.sqrt(emb.reduce((s, v) => s + v * v, 0));
        magnitudes.push(mag);
    }
    const maxMag = Math.max(...magnitudes, 0.001);
    
    for (let i = 0; i < graph.numNodes; i++) {
        const pos = graphState.positions[i];
        const normMag = magnitudes[i] / maxMag;
        
        const r = Math.round(68 + normMag * 120);
        const g = Math.round(119 - normMag * 50);
        const b = Math.round(200 - normMag * 100);
        
        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
        ctx.strokeStyle = '#1e293b';
        ctx.lineWidth = 2;
        
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 18, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        ctx.fillStyle = 'white';
        ctx.font = 'bold 11px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(i.toString(), pos.x, pos.y);
    }
}

function clearGraphViz() {
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    graphState = null;
}

// ==================== MODEL PERSISTENCE ====================

function convertDenseFormatToNeurons(denseLayer) {
    // Convert from DenseLayer.getWeights() format to neuron format
    const weights = denseLayer.weights || [];
    const biases = denseLayer.biases || [];
    const neurons = [];
    
    for (let i = 0; i < biases.length; i++) {
        neurons.push({
            weights: weights[i] || [],
            bias: biases[i] || 0
        });
    }
    
    return neurons;
}

function saveModel() {
    if (!currentGNN) {
        alert('No model to save. Train first.');
        return;
    }
    
    // Convert to Pascal-compatible neuron format
    const convertLayerToJSON = (layer) => {
        const denseWeights = layer.getWeights();
        return {
            num_inputs: layer.inputSize,
            num_outputs: layer.outputSize,
            neurons: convertDenseFormatToNeurons(denseWeights)
        };
    };
    
    const data = {
        feature_size: currentGNN.featureSize,
        hidden_size: currentGNN.hiddenSize,
        output_size: currentGNN.outputSize,
        num_message_passing_layers: currentGNN.numMPLayers,
        learning_rate: currentGNN.learningRate,
        activation: currentGNN.activationType,
        loss_type: currentGNN.lossFunctionType,
        max_iterations: 100,
        message_layers: currentGNN.messageLayers.map(convertLayerToJSON),
        update_layers: currentGNN.updateLayers.map(convertLayerToJSON),
        readout_layer: convertLayerToJSON(currentGNN.readoutLayer),
        output_layer: convertLayerToJSON(currentGNN.outputLayer),
        loss_history: lossHistory
    };
    
    try {
        localStorage.setItem('gnn_model', JSON.stringify(data));
        document.getElementById('output').innerHTML += '<div class="success-msg">Model saved to localStorage</div>';
    } catch (e) {
        console.error('localStorage save failed:', e);
    }
    
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'gnn_model.json';
    a.click();
    URL.revokeObjectURL(url);
}

function loadModel() {
     const stored = localStorage.getItem('gnn_model');
     if (stored) {
         try {
             const data = JSON.parse(stored);
             loadModelData(data);
             return;
         } catch (e) {
             console.error('Failed to load from localStorage:', e);
         }
     }
     
     const input = document.createElement('input');
     input.type = 'file';
     input.accept = '.json';
     input.onchange = async (e) => {
         const file = e.target.files[0];
         if (!file) return;
         
         try {
             const text = await file.text();
             const data = JSON.parse(text);
             loadModelData(data);
         } catch (err) {
             alert('Failed to load model: ' + err.message);
         }
     };
     input.click();
 }

 function convertNeuronsToDenseFormat(layerData) {
     // Convert from neurons array format to DenseLayer.setWeights format
     if (!layerData || !layerData.neurons) return null;
     
     const weights = layerData.neurons.map(n => n.weights || []);
     const biases = layerData.neurons.map(n => n.bias || 0);
     
     return { weights, biases };
 }
 
 function loadModelData(data) {
     // Extract config with fallback support
     const featureSize = data.feature_size || data.featureSize || (data.config?.featureSize) || (data.weights?.featureSize);
     const hiddenSize = data.hidden_size || data.hiddenSize || (data.config?.hiddenSize) || (data.weights?.hiddenSize);
     const outputSize = data.output_size || data.outputSize || (data.config?.outputSize) || (data.weights?.outputSize);
     const numMPLayers = data.num_message_passing_layers || data.numMPLayers || (data.config?.numMPLayers) || (data.weights?.numMPLayers);
     const learningRate = data.learning_rate || data.learningRate || 0.01;
     const activation = data.activation || data.activationType || 'relu';
     const lossType = data.loss_type || data.lossFunctionType || 'mse';
     
     if (!featureSize || !hiddenSize || !outputSize || !numMPLayers) {
         alert('Invalid model data: missing configuration');
         return;
     }
     
     document.getElementById('featureSize').value = featureSize;
     document.getElementById('hiddenSize').value = hiddenSize;
     document.getElementById('outputSize').value = outputSize;
     document.getElementById('numLayers').value = numMPLayers;
     document.getElementById('learningRate').value = Math.log10(learningRate);
     document.getElementById('activation').value = activation;
     document.getElementById('lossFunction').value = lossType;
     updateSliderDisplay();
     
     currentGNN = new GraphNeuralNetwork(
         featureSize,
         hiddenSize,
         outputSize,
         numMPLayers
     );
     
     currentGNN.learningRate = learningRate;
     currentGNN.activationType = activation;
     currentGNN.lossFunctionType = lossType;
     
     // Get layer data - handle both snake_case and camelCase
     const messageLayers = data.message_layers || data.messageLayers || [];
     const updateLayers = data.update_layers || data.updateLayers || [];
     const readoutLayer = data.readout_layer || data.readoutLayer;
     const outputLayer = data.output_layer || data.outputLayer;
     
     // Convert each layer from neuron format to DenseLayer format
     messageLayers.forEach((layer, i) => {
         const converted = convertNeuronsToDenseFormat(layer);
         if (converted && i < currentGNN.messageLayers.length) {
             currentGNN.messageLayers[i].setWeights(converted);
         }
     });
     
     updateLayers.forEach((layer, i) => {
         const converted = convertNeuronsToDenseFormat(layer);
         if (converted && i < currentGNN.updateLayers.length) {
             currentGNN.updateLayers[i].setWeights(converted);
         }
     });
     
     if (readoutLayer) {
         const converted = convertNeuronsToDenseFormat(readoutLayer);
         if (converted) currentGNN.readoutLayer.setWeights(converted);
     }
     
     if (outputLayer) {
         const converted = convertNeuronsToDenseFormat(outputLayer);
         if (converted) currentGNN.outputLayer.setWeights(converted);
     }
     
     lossHistory = data.loss_history || data.lossHistory || [];
     updateLossChart();
     
     // Set up for prediction - user needs to configure graph/target after loading
     document.getElementById('trainBtn').disabled = false;
     document.getElementById('predictBtn').disabled = false;
     
     visualizeGNNArchitecture(currentGNN, 'networkVisualization');
     document.getElementById('output').innerHTML = `<div class="success-msg">Model loaded successfully. Configure graph and target, then click Train or Predict.</div>`;
 }

// ==================== GNN ARCHITECTURE VISUALIZATION ====================

function visualizeGNNArchitecture(gnn, containerId) {
    const container = document.getElementById(containerId);
    const section = document.getElementById('networkVizSection');
    if (!container || !section) return;
    
    // Show the section
    section.style.display = 'block';
    
    // Read from GNN object if available, otherwise from form
    const featureSize = gnn?.featureSize ?? parseInt(document.getElementById('featureSize').value) ?? 3;
    const hiddenSize = gnn?.hiddenSize ?? parseInt(document.getElementById('hiddenSize').value) ?? 16;
    const outputSize = gnn?.outputSize ?? parseInt(document.getElementById('outputSize').value) ?? 2;
    const numMPLayers = gnn?.numMPLayers ?? parseInt(document.getElementById('numLayers').value) ?? 2;
    
    const spacing = 85;
    const padding = 20;
    const legendSpace = 80;
    const totalLayers = 2 + numMPLayers * 2 + 2;
    const totalWidth = totalLayers * spacing + padding * 2 + legendSpace;
    const totalHeight = 200;
    
    const svgContainer = document.createElement('div');
    svgContainer.setAttribute('style', 'overflow-x: auto; overflow-y: hidden; border: 1px solid #ccc; background: #fafafa; border-radius: 4px; margin: 1rem 0; height: 220px;');
    
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', totalWidth);
    svg.setAttribute('height', totalHeight);
    svg.setAttribute('style', 'display: block;');
    
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    defs.innerHTML = `
        <linearGradient id="msgGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#4285f4;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#1967d2;stop-opacity:1" />
        </linearGradient>
        <linearGradient id="updGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#34a853;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#188038;stop-opacity:1" />
        </linearGradient>
        <linearGradient id="readGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#ea4335;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#c5221f;stop-opacity:1" />
        </linearGradient>
        <linearGradient id="outGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#fbbc04;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#f57d00;stop-opacity:1" />
        </linearGradient>
    `;
    svg.appendChild(defs);
    
    let xPos = padding + legendSpace;
    const cy = totalHeight / 2;
    
    function drawBox(x, y, w, h, fill, stroke, texts) {
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        box.setAttribute('x', x - w/2);
        box.setAttribute('y', y - h/2);
        box.setAttribute('width', w);
        box.setAttribute('height', h);
        box.setAttribute('fill', fill);
        box.setAttribute('stroke', stroke);
        box.setAttribute('stroke-width', 1.5);
        box.setAttribute('rx', 3);
        g.appendChild(box);
        
        texts.forEach((t, i) => {
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', x);
            text.setAttribute('y', y - 18 + i * 14);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('font-size', t.size || '9');
            if (t.bold) text.setAttribute('font-weight', 'bold');
            text.setAttribute('fill', t.color || 'white');
            text.textContent = t.text;
            g.appendChild(text);
        });
        svg.appendChild(g);
    }
    
    // Input layer
    drawBox(xPos, cy, 50, 70, '#e8f5e9', '#2e7d32', [
        { text: 'Input', size: '10', bold: true, color: '#1b5e20' },
        { text: `${featureSize}f`, size: '9', color: '#1b5e20' }
    ]);
    xPos += spacing;
    
    // Message passing layers
    for (let i = 0; i < numMPLayers; i++) {
        const inputSize = i === 0 ? featureSize * 2 : hiddenSize * 2;
        drawBox(xPos, cy, 56, 70, 'url(#msgGrad)', '#1967d2', [
            { text: `Msg${i+1}`, size: '9', bold: true },
            { text: `${inputSize}${hiddenSize}`, size: '8' }
        ]);
        xPos += spacing;
        
        drawBox(xPos, cy, 56, 70, 'url(#updGrad)', '#188038', [
            { text: `Upd${i+1}`, size: '9', bold: true },
            { text: `${hiddenSize*2}${hiddenSize}`, size: '8' }
        ]);
        xPos += spacing;
    }
    
    // Readout
    drawBox(xPos, cy, 50, 70, 'url(#readGrad)', '#c5221f', [
        { text: 'Readout', size: '9', bold: true },
        { text: `${hiddenSize}`, size: '8' }
    ]);
    xPos += spacing;
    
    // Output
    drawBox(xPos, cy, 56, 70, 'url(#outGrad)', '#f57d00', [
        { text: 'Output', size: '10', bold: true },
        { text: `${outputSize}c`, size: '8' }
    ]);
    
    // Legend
    const legendItems = [
        { label: 'Msg', color: 'url(#msgGrad)' },
        { label: 'Upd', color: 'url(#updGrad)' },
        { label: 'Read', color: 'url(#readGrad)' },
        { label: 'Out', color: 'url(#outGrad)' }
    ];
    let ly = cy - 30;
    legendItems.forEach(item => {
        const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        box.setAttribute('x', padding + 5);
        box.setAttribute('y', ly);
        box.setAttribute('width', 10);
        box.setAttribute('height', 10);
        box.setAttribute('fill', item.color);
        box.setAttribute('stroke', '#666');
        box.setAttribute('stroke-width', 0.5);
        box.setAttribute('rx', 2);
        svg.appendChild(box);
        
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', padding + 19);
        text.setAttribute('y', ly + 8);
        text.setAttribute('font-size', '9');
        text.setAttribute('fill', '#333');
        text.textContent = item.label;
        svg.appendChild(text);
        ly += 13;
    });
    
    svgContainer.innerHTML = '';
    svgContainer.appendChild(svg);
    container.innerHTML = '';
    container.appendChild(svgContainer);
}

// ==================== INITIALIZATION ====================

buildGraphInputs();
updateSliderDisplay();
updateEdgeStats();
updateLossChart();
</script>
</body>
</html>
